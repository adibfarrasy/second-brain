As a backend engineer, have you ever been told (or conversely, in the position of telling others) that you must tread with caution whenever you're trying to make a change in a particular function, especially things that involve handling customers' money (e.g. checkout, refund, or invoice)? Does your company have that one or two go-to guy who knows that particular feature inside and out, the ones that you must always consult if you want to contribute a change to that feature? Are those critical functions 2000+ lines long with complex control flow (and poor test coverage)?
Before you read any further, this post is about Domain-Driven Design; particularly about how a good project structure can make projects easy to change and maintain, and expose hidden control flows.
Backend codebases usually start well-structured, then feature requests and refactoring efforts happen and in just a couple of months it looks like a badly Frankenstein'd monster. The problem of course is not introducing changes - companies' products must either evolve or die; it's the lack of insight on how to maintain the codebase to be easy to change. DDD fills in this knowledge gap by introducing the concepts of entities and domain events. It's not the easiest thing to understand at first, and that's why this article comes with a sample repository written in Go that you can refer to here: INSERT GITHUB REPO LINK HERE
The sample code only focus on one feature: create an order. It makes a synchronous call to baskets service and save the items to an order. Then it publishes a domain event that signals an order is created, so that other functions that listen to that event (via pub-sub; not the fancy one, just a good ol' global function hashmap), i.e. notifications service and baskets service can do their things. The core functionality stays lean (a naive implementation would just write all the side-effect function calls in the core function), and introducing a new feature (side-effect function) is simple: just register a new function that triggers when an event is published. Did I mention that every event handler is inside a global hashmap? No need to codedive to know what other services are impacted and how, just look at the registered functions per event in that hashmap. The event handlers are synchronous for simplicity, but they can easily be multi-threaded for improving the performance.
Hope it helps!